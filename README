----------------------------------------------------------------------
                           Onion Hash v0.0.2
----------------------------------------------------------------------


CONTENT
~~~~~~~
CHANGELOG   - lists the latest improvements/fixes
LICENSE     - for those who believe in copyright
Makefile    - builts the binary (on most systems)
README      - the file you are reading right now
onionhash.c - computes customized hashes and keys


INSTALL
~~~~~~~
* you need to have a recent version of OpenSSL installed
* type "make" and pray (autoconf/make support in v0.0.3)
* run the program, get some coffee. come back next month


ABOUT
~~~~~
This program allows you to create customized onionhashes for Tor
hidden services. It's based on THC's Fuzzy Fingerprint technique
(paper available at http://thc.org/papers/ffp.pdf). "Customized"
means, you can choose parts of the hash to match certain regular
expression patterns.

>> example: create private key for test*.onion:

$ ./onionhash 
Usage: onionhash pattern
base32 alphabet allows letters [a-z] and digits [2-7]
pattern can be a POSIX-style regular expression, e.g.
  xxx           must contain 'xxx'
  bar$          must end with 'bar'
  ^foo          must begin with 'foo'
  b[a4]r        may contain leetspeech ;)
  ^ab|^cd       must begin with 'ab' or 'cd'
  [a-z]{16}     must contain letters only, no digits
  ^dusk.*dawn$  must begin with 'dusk' and end with 'dawn'

$ ./onionhash ^test
----------------------------------------------------------------
Found matching pattern after 99133 tries: testvztz3tfoiofv.onion
----------------------------------------------------------------
-----BEGIN RSA PRIVATE KEY-----
MIICXgIBAAKBgQC3R85m6NQaA1ZjaYqvz1hvFIjbL4RtKdJbG8hlC9xEBkvfr/BG
8Z5vDiUzdbDt8mEBuZUDanx80uGJvbXTgmczX0UlkEOgGiZ8RKpnsbKaf/EJNrIw
T7MSXQmWNcm22nDeViV7fwy+Usyal2RE5cdVCFsPtEbVZqCumlKkEgCyFwIDBAZ7
AoGBAJSa2cGuru/XhzJAEAIwHZbgPDnum9T/srOYxUKW6afHZeOu5S4Cclwb+xb/
pGOtzn71XZfCKMfiVdxB/f3XTcRrYB2VnBoNToTD7WfH6DksdDf4zunqiEjvxi9K
R+tKhxmF7OedrRt8wIhUmFd1E2Q9nbTHI6icdB4kR4QkYKZzAkEA5M6samK7+495
6SWpRXiePIs7sHKWuxdCrG7kW5RNJrv2CcGYwK46TPcaXBcRfM4eq9+9PGoKi0IO
gSpOZ5vRYQJBAM0QAZYTZ6ApD014x372MX1ZNofuYL/+XF8ZPZV6Sh4+9MUBuNPb
yL7BENDr6pX4Zm6OepvAphhCa4vGno2pHncCQQCQnfhUCHANU4bjtX4EOoI63WDq
UwBOeIWxu0YvGt7Z25Dg9CNz/aX8UZIoj6VyKxLRbR9+K3mNrNgaopW+ZDKzAkEA
ttgTK1ALe+3v+5H+Ez1SvFPREDFcHihrfD1Ipc5zicY9ixTArgdyZvk+Pi+AMBVV
sL2HWvjRLEAgRclvKfkwWwJAFtM+BIGRM5me+fMALuBBEtKnbJ6maflsyucErEb0
pIIBkovF5oyWO3lSBmtStJIANNkHOg8aXqjcgPKusDN7CQ==
-----END RSA PRIVATE KEY-----

The generated key can now be saved as file 'private_key' in your
HiddenServiceDir. Afterwards reload Tor (e.g. by sending SIGHUP)
and you should be reachable as testvztz3tfoiofv.onion.


SECURITY
--------
To evaluate the security of the generated private keys, one must
first know how the RSA-algorithm as implemented in OpenSSL works:

1. Choose two large prime numbers p, and q, such that p != q,
   randomly and independently of each other. Compute is N = pq.
2. Compute the totient phi(n) = (p-1)(q-1)
3. Choose an integer 1 < e < phi(n), which is coprime to phi(n)
4. Compute d such that ed = 1 mod phi(n)

What's differnet in OnionHash? - We only chose the first expoment e
by random. The next one is calculated as e+2. That's it. Is it less
secure? I bet no, but still i say, you should not bet on this 100%. 


Comment: The MetaWiki admin claims in the QuestionAndAswers section of
         the HiddenWiki that OnionHash would create insecure keys. Not
         only hasn't he/she provided any kind of proof for this really
         bold statement but also are my comments on his/her assumption
         censored/deleted. I hereby repeat my invitation - come to ORC
         (irc://3d2et7ek4jjhnv3k.onion) and let us discuss this issue.
         Torizens believe in math, not in propaganda.

Updates: OnionHash v0.0.1 had a comment that said something like "only
         the first key is securely generated". I must admit, that this
         is a bit misleading. it should better say "only the first key
         is chosen randomly by OpenSSL's RSA_generate_key() function".


PERFORMANCE
-----------
First of all, you cannot create any hash you want (in adequate time).
If you could easily find collisions on the first half (80 bit) of the
SHA1 hash, Torland would be in serious trouble.

The speed of the brute_force_onion() loop can be divided in:
+----------------------------------------+
| function(s)          | CPU consumption |
|----------------------+-----------------+
| compute next RSA key |            4.6% |
|   PEM-encode RSA key |           59.4% |
|    compute SHA1 hash |           30.6% |
|   BASE32-encode hash |            2.7% |
|   compare with regex |            2.7% |
+----------------------------------------+

On a 1.8GHz x86-machine, i get about 250k hashes per second:
+-----------------------------------------------------------------+
| chars | avarange number of tries | avarange time on i386/1.8GHz |
|-------+--------------------------+------------------------------|
|     1 |              32^1  =  32 |                       <1 sec |
|     2 |              32^2  =  1k |                       <1 sec |
|     3 |              32^3  = 32k |                       <1 sec |
|     4 |              32^4  =  1m |                        4 sec |
|     5 |              32^5  = 32m |                        2 min |
|     6 |              32^6  =  1g |                       1 hour |
|     7 |              32^7  = 32g |                       2 days |
|     8 |              23^8  =  1t |                      50 days |
|     9 |              32^9  = 32t |                      5 years |
|    16 |              32^16 =  1y |                     too long |
+-----------------------------------------------------------------+
Note: you can speed it up if you're only interested in a certain
      string to appear somewhere, instead of at a fixed position
      like the beginning of the hash. Also you could make use of
      'leetspeech', therfore allowing both, e.g. [3e] or [7t] ;)


BUGS
----
Registration of an onionhash containing the string 'coca-cola' on the
dirserver(s) may lead to persecution by the almighty trademark police.


TODO
----
* write an autoconf/make script for building system-independent Makefiles
* don't do malloc() and free() in every loop, do it once before and after
* use something faster than OpenSSL's i2d_RSAPublicKey() for PEM-encoding
* optinal (as configure parameter) use an assembly implementation of SHA1
* optinal, use GnuMP's mpz_invert() instead of OpenSSL's BN_mod_inverse()
* make sure the requested onionhash contains base32 chars (2-7, a-z) only
* make sure the requested onionhash is valid (= not longer that 16 chars)
